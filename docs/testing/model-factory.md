# ModelFactory

A ModelFactory is a faker based model stub generator.

In the first step, building the factory class, you can define via `FactoryField`s customizations of the parameters passed
for the fakers for the model.

The second step, is making a factory instance. Here can values be passed which should be used for the model. They are baked in
the factory instance. But you are able to overwrite them in the last step or to exclude them.

The last step, is building a stub model via `build`. This is an **instance-only** method not like the other build method other model definitions.

In short the sequence is like follows:

Factory definition -> Factory instance -> Factory build method -> stubbed Model instance to play with.

You can reuse the factory instance to produce a lot of models.

Example:

```python
{!> ../docs_src/testing/factory/factory_basic.py !}
```

Now we have a basic working model. Now let's get more complicated. Let's remove the implicit id field via factory fields


```python
{!> ../docs_src/testing/factory/factory_fields_exclude.py !}
```


!!! Note
    Every Factory class has an own internal faker instance. If you require a separate faker you have to provide it in the build method
    as `faker` keyword parameter.

## Parametrize

For customization you have two options: provide parameters to the corresponding faker method or to provide an own callable which can also receive parameters.
When no callback is provided the mappings are used which use the field type name of the corresponding edgy field.

E.g. CharFields use the "CharField" mapping.

```python
{!> ../docs_src/testing/factory/factory_parametrize.py !}
```

### Setting database and schema

By default the database and schema of the model is used unchanged. You can however provide an other database or schema than the default by defining
them as class or instance variables (not by keyword arguments) on a Factory.
The syntax is the same like for database models, you define them on the main model. You can also overwrite them one-time in the build method.

- `__using_schema__` (str or None)
- `database` (Database or None)

!!! Note
    There is a subtle difference between database models and ModelFactories concerning `__using_schema__`.
    When `None` in `ModelFactory` the default of the model is used while in database models None selects the main schema.


### Parametrizing relation fields

Relation fields are fields like ForeignKey ManyToMany, OneToOne and RelatedFIeld.

For parametrizing relation fields exist two variants:

1. Pass `build()` parameters as field parameters. For 1-n relations there are two extra parameters min=0, max=100, which allow to specify how many
   instances are generated.
2. Transform a ModelFactory to a FactoryField.

The first way cannot be used with RelatedFields, which are automatically excluded.
You can however pass values to them via the second way.

To transform a ModelFactory there are two helper classmethods:

1. `to_factory_field`
2. `to_list_factory_field(min=0, max=100)`


### Special parameters

There are two special parameters which are always available for all fields:

- randomly_unset
- randomly_nullify

The first randomly excludes a field value. The second randomly sets a value to None.
You can either pass True for a equal distribution or a number from 0-100 to bias it.


### Excluding a field

To exclude a field there are 3 ways

- Provide a field with `exclude=True`. It should be defined under the name of the value.
- Add the field name to the exclude parameter of build.
- Raise `edgy.testing.exceptions.ExcludeValue` in a callback.


## Build

The central method for factories is `build()`. It generates the model instance.
It has also some keyword parameters for post-customization. They are also available for default relationship fields
or for wrapping factory fields via the `to_factory_field` or `to_list_factory_field` classmethods.

The parameters are:

- faker (not available for factories for relationship fields. Here is the provided faker or faker of the parent model used). Provide a custom Faker instance.
  This can be useful when the seed is modified,
- parameters ({fieldname: {parametername: parametervalue} | FactoryCallback}): Provide per field name either a callback which returns the value or parameters.
- overwrites ({fieldname: value}): Provide the value directly. Skip any evaluation
- exclude (e.g. {"id"}): Exclude the values from stubbing. Useful for removing the autogenerated id.
- database (Database | None | False): Use a different database. When None pick the one of the ModelFactory if available, then fallback to the model.
  When `False`, just use the one of the model.
- schema (str | None | False):  Use a different schema. When `None` pick the one of the ModelFactory if available, then fallback to the model.
  When `False`, just use the one of the model.

## Mappings

Mappings are inherited from the parents. The more recent mapping definition for a field type wins.

## Model Validation

By default a validation is executed if the model can ever succeed in generation. If not an error
is printed but the model still build.
If you dislike this behaviour, you can disable the implicit model validation via:

```python
class UserFactory(ModelFactory, model_validation="none"):
    ...
```

You have following options:

- `none`: No implicit validation.
- `warn`: Warn for unsound factory/model definitions which produce other errors than pydantic validation errors. Default.
- `error`: Same as warn but reraise the exception instead of a warning.
- `pedantic`: Raise even for pydantic validation errors.
