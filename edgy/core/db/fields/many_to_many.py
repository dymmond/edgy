from typing import TYPE_CHECKING, Any, Dict, Optional, Sequence, Tuple, Type, TypeVar, Union, cast

from edgy.core.db.constants import CASCADE
from edgy.core.db.fields.base import BaseField, BaseForeignKey
from edgy.core.db.fields.factories import ForeignKeyFieldFactory
from edgy.core.db.fields.foreign_keys import ForeignKey
from edgy.core.db.relationships.relation import Relation
from edgy.core.terminal import Print
from edgy.core.utils.models import create_edgy_model

if TYPE_CHECKING:

    from edgy import Model

T = TypeVar("T", bound="Model")


terminal = Print()


class BaseManyToManyForeignKeyField(BaseForeignKey):
    is_m2m: bool = True
    def __init__(
        self,
        *,
        to_fields: Sequence[str] = (),
        from_fields: Sequence[str] = (),
        through: Union[str, Type["Model"]] = "",
        **kwargs: Any,
    ) -> None:
        self.to_fields = to_fields
        self.from_fields = from_fields
        self.through = through

        super().__init__(**kwargs)

    def add_model_to_register(self, model: Any) -> None:
        """
        Adds the model to the registry to make sure it can be generated by the Migrations
        """
        self.registry.models[model.__name__] = model

    def create_through_model(self) -> None:
        """
        Creates the default empty through model.

        Generates a middle model based on the owner of the field and the field itself and adds
        it to the main registry to make sure it generates the proper models and migrations.
        """
        from edgy.core.db.models.metaclasses import MetaInfo

        self.to = self.target
        __bases__: Tuple[Type["Model"], ...] = ()

        if self.through:
            if isinstance(self.through, str):
                self.through = self.registry.models[self.through]
            through = cast(Type["Model"], self.through)
            if through.meta.abstract:
                __bases__ = (through,)
            else:
                name = self.to.__name__.lower()
                if name not in through.meta.multi_related:
                    through.meta.multi_related.append(name)
                return

        owner_name = self.owner.__name__
        to_name = self.to.__name__
        class_name = f"{owner_name}{to_name}"
        tablename = f"{owner_name.lower()}s_{to_name}s".lower()

        new_meta: MetaInfo = MetaInfo(None, tablename=tablename, registry=self.registry, multi_related=[to_name.lower()])

        # Define the related names
        owner_related_name = (
            f"{self.related_name}_{class_name.lower()}s_set"
            if self.related_name
            else f"{owner_name.lower()}_{class_name.lower()}s_set"
        )

        to_related_name = (
            f"{self.related_name}" if self.related_name else f"{to_name.lower()}_{class_name.lower()}s_set"
        )
        fields = {
            f"{owner_name.lower()}": ForeignKey(
                self.owner,
                null=True,
                on_delete=CASCADE,
                related_name=owner_related_name,
                related_fields=self.from_fields
            ),
            f"{to_name.lower()}": ForeignKey(self.to, null=True, on_delete=CASCADE, related_name=to_related_name,
                related_fields=self.to_fields),
        }

        # Create the through model
        through_model = create_edgy_model(
            __name__=class_name,
            __module__=self.__module__,
            __definitions__=fields,
            __metadata__=new_meta,
            __bases__=__bases__
        )
        self.through = through_model
        self.add_model_to_register(self.through)

    def to_model(self, field_name: str, value: Any, phase: str = "") -> Dict[str, Any]:
        """
        Meta field
        """
        return {}

    def has_default(self) -> bool:
        """Checks if the field has a default value set"""
        return False

    def get_default_values(self, field_name: str, cleaned_data: Dict[str, Any]) -> Any:
        """
        Meta field
        """
        return {}

    def __get__(self, instance: "Model", owner: Any = None) -> Relation:
        relation = Relation(through=self.through, to=self.to, owner=self.owner, instance=instance)
        if instance:
            instance.__dict__[self.name] = relation
        return relation


class ManyToManyField(ForeignKeyFieldFactory):
    _type: Any = Any
    _bases = (BaseManyToManyForeignKeyField,)

    def __new__(  # type: ignore
        cls,
        to: Union["Model", str],
        *,
        through: Optional["Model"] = None,
        from_fields: Sequence[str] = (),
        to_fields: Sequence[str] = (),
        **kwargs: Any,
    ) -> BaseField:
        for argument in ["null", "on_delete", "on_update"]:
            if kwargs.get(argument, None):
                terminal.write_warning(f"Declaring `{argument}` on a ManyToMany relationship has no effect.")
        kwargs["null"] = True
        kwargs["on_delete"] = CASCADE
        kwargs["on_update"] = CASCADE

        return super().__new__(cls, to=to, through=through, **kwargs)

ManyToMany = ManyToManyField
